#!/usr/bin/env python

import sys
import json
import pika
import pytz
import struct
import random
import ConfigParser
import dateutil.parser
from pprint import pprint
from datetime import datetime
from influxdb import InfluxDBClient

def insert_into_influxdb(data):
    host='localhost'
    port=8086
    user = 'root'
    password = 'root'
    dbname = 'example'
    dbuser = 'smly'
    dbuser_password = 'my_secret_password'
    query = 'select value from cpu_load_short;'
    client = InfluxDBClient(host, port, user, password, dbname)

    print("Create database: " + dbname)
    client.create_database(dbname)

    print("Create a retention policy")
    client.create_retention_policy('awesome_policy', '3d', 3, default=True)

    print("Switch user: " + dbuser)
    client.switch_user(dbuser, dbuser_password)

    json_body = [
        {
            "measurement": "point",
            "tags": {
                "node_serial": str(data['parsed']['serial']),
                "key": str(data['parsed']['key']),
                "value": data['parsed']['value'],
            },
            "time": dateutil.parser.parse(data['gw_timestamp']),
            "fields": {
                "value": data['parsed']['value'],
                "rssi": data['rssi']
            }
        }
    ]

    print("Write points: {0}".format(json_body))
    ret = client.write_points(json_body)
    if not ret:
        raise Exception("Unable to insert data to InfluxDB")

def callback(channel, method, properties, body):
    data = json.loads(body)

    print"RAW DATA:" 
    pprint(data)

    data['gw_timestamp'] = str(data['gw_timestamp'])
    data['payload'] = str(data['payload'])

    pl = data['payload'].decode('hex')

    data['parsed'] = {}
    data['parsed']['serial'] = struct.unpack('H', pl[1:3])[0]
    data['parsed']['key']    = struct.unpack('H', pl[3:5])[0]
    data['parsed']['value']  = struct.unpack('f', pl[5:9])[0]

    print"DATA:" 
    pprint(data)

    try:
        print("Prepared parsed data to DB") 
        insert_into_influxdb(data)
        channel.basic_ack(delivery_tag = method.delivery_tag)

    except Exception as e:
        print("Exception occured!")
        print str(e)
        channel.basic_nack(delivery_tag = method.delivery_tag, requeue=False)

config = ConfigParser.RawConfigParser()
config.read('local.cfg')
mq_host='127.0.0.1'

credentials = pika.PlainCredentials('test', 'myonetest')

connection = pika.BlockingConnection(
    pika.ConnectionParameters(
        host=mq_host,
        virtual_host="iot",
        credentials=credentials
    )
)

channel = connection.channel()
channel.basic_qos(prefetch_count=1)
result = channel.queue_declare(queue='for_influxdb', durable=True)
channel.queue_bind(exchange='iot', queue=result.method.queue)
channel.basic_consume(callback, queue='for_influxdb')
try:
    channel.start_consuming()
except KeyboardInterrupt:
    channel.stop_consuming()
connection.close()
